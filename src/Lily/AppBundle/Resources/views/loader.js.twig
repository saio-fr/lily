(function (window, undefined) {"use strict";/* jshint strict:false */
var _ = (function () {

  if (_) return _;

  /*
   * isObject, extend, isFunction, throttle, debounce and each are taken from undescore/lodash in
   * order to remove the dependency
   */
  return {

    isArray: function(arr) {
      return Object.prototype.toString.call(arr) === '[object Array]';
    },

    isObject: function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    },

    isFunction: function(obj) {
      if (typeof /./ !== 'function' && typeof Int8Array !== 'object') {
        return typeof obj === 'function' || false;
      } else {
        return toString.call(obj) === '[object Function]';
      }
    },

    isString: function(obj) {
      return toString.call(obj) === '[object String]';
    },

    isOwn: function(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    },

    bind: function(fn, context) {
      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!this.isFunction(fn)) {
          return undefined;
      }

      var args = slice.call( arguments, 2 );

      return function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
    },

    each: function(obj, iteratee) {
      var i, length;
      if (_.isArray(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
             iteratee(obj[key], key, obj);
          }
        }
      }
    },

    extend: function(obj) {
      if (!this.isObject(obj)) {
        return obj;
      }
      var source, prop;
      for (var i = 1, length = arguments.length; i < length; i++) {
        source = arguments[i];
        for (prop in source) {
          if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
            Object.defineProperty(obj, prop, propertyDescriptor);
          } else {
            obj[prop] = source[prop];
          }
        }
      }
      return obj;
    },

    throttle: function(func, wait, options) {
      var context, args, result;
      var timeout = null;
      var previous = 0;
      if (!options) options = {};
      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };
      return function() {
        var now = _.now();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    },

    debounce: function(func, wait, immediate) {
      var timeout, args, context, timestamp, result;

      var later = function() {
        var last = _.now() - timestamp;

        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          }
        }
      };

      return function() {
        context = this;
        args = arguments;
        timestamp = _.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }

        return result;
      };
    },

    once: function(func) {
      var result;
      var wasCalled = false;

      return function() {
        if (wasCalled)
         return result;
        else {
          wasCalled = true;
          result = func.apply(this, arguments);
          func = null;
          return result;
        }
      };
    },

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    keys: function(obj) {
      if (!_.isObject(obj)) return [];
      if (Object.keys) return Object.keys(obj);
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys.push(key);
      return keys;
    },

    addEvent: function(el, type, callback) {
      if (window.addEventListener) { // modern browsers including IE9+
        el.addEventListener(type, callback, false);
      } else if (window.attachEvent) { // IE8 and below
        el.attachEvent('on' + type, callback);
      } else {
        el['on' + type] = callback;
      }
    },

    removeEvent: function(el, type, callback) {
      if (window.removeEventListener) {
        el.removeEventListener(type, callback, false);
      } else if (window.detachEvent) {
        el.detachEvent('on' + type, callback);
      } else {
        el['on' + type] = null;
      }
    },

    stopPropagation: function(type) {
      var e = type || window.event;
      e.cancelBubble = true;
      if (e.stopPropagation) e.stopPropagation();
    },

    // Checks if browser id IE 9 or lower
    isMsie: function() {
      if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
        var ieversion = +(RegExp.$1);
        if (ieversion < 10) {
          return true;
        }
      }
    },

    isUnsuported: function() {
      if (this.isMsie())
        return true;
      if (!window.postMessage)
        return true;
      if (!window.JSON)
        return true;
      try {
        window.postMessage('ping', '*');
      } catch (err) {
        return true;
      }

      return false;
    },

    now: Date.now,
  };

})();

;/* jshint strict:false */
/* globals _ */

/**
 * Small events library taken from Backbone.js events api
 */
var Events = (function () {

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  var Events = {
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    },

    delegateEvents: function(obj, events) {
      if (!events) return;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        method = _.bind(method, this);
        this.listenTo(obj, key, method);
      }
      return this;
    },

    undelegateEvents: function() {
      this.stopListening();
      return this;
    },

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {
    listenTo: 'on',
    listenToOnce: 'once'
  };

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  return Events;
})();

;/* jshint strict:false */
var xdm = (function() {

  return {
    sendMessage: function(name, data) {
      var message = JSON.stringify({
        scope: 'client',
        name: name,
        data: data
      });

      console.log('client' + ': ' + name);

      var send = (function(target, message) {
        return function() {
          var targetWindow = target.window;
          if (targetWindow) {
            targetWindow.postMessage(message, target.origin);
          } else {
            setTimeout(send, 500);
          }
        };

      })(this, message);

      // if (this.isReady()) {
        send();
      // } else {
      //   this.on('ready', send);
      // }
    }
  };

})();

;/* jshint strict: false */
/* globals _, window, Events, sdk, saio */

/**
 * The saio object will be used as a global event bus by a frame app
 * like lily or widget, to communicate across apps without needing
 * knowledge of the internals of the others
 *
 * It also has utility methods attatched to it, to set/get a registered app
 * or manipulate urls.
 *
 */
var core = function() {

  var stylesUrl = '{{ licence|customerDir|raw }}/css/lily-float.css';
  var appsRegistry = {};

  return _.extend({
    hostDocument: window.document,
    hostWindow: window,
    hostBody: window.document.getElementsByTagName('body')[0],
    emptyLink: window.document.createElement('a'),

    origin: window.location.origin || this.getOrigin(), // IE 11+ only
    host: window.location.host,

    events: {
      // Comming from lily app
      'lily.onReady': 'onLilyReady',
      'lily.onExpand': 'onLilyExpand',

      // Comming from widget app
      'widget.click': 'onWidgetClick',

      // comming from sdk
      'config.setOperatorGroup': 'setOperatorGroup',

      // comming from third party frames
      'lily.messageToOperator': 'onMessageToOperator'
    },

    initialize: function() {

      // Register this unique id for the host window
      this.registerApp(this.hostWindow, 'host');

      // Load the external stylesheet used to style the widget
      // and the app wrapper
      this.loadStylesheet(stylesUrl);

      // Create listeners for the events listed in the 'events' objects
      this.delegateEvents(this, this.events);

      // Listen for messages sent to the hostWindow using the postMessage API
      // (Messages we read this way can come from multiple third parties
      // and should not be trusted.)
      _.addEvent(this.hostWindow, 'message', _.bind(this.onTargetMessage, this));
    },

    /**
     * Methods called from calls to sdk config triggered events
     */

    // Follow the information to lily that the operator group
    // for this page should be groupId
    setOperatorGroup: function(groupId) {
      var lily = this.getRegisteredApp('lily');
      lily.sendMessage('config.setOperatorGroup', groupId);
    },

    /**
     * Methods called after a event from lilyEvents was fired
     */
    onLilyReady: function() {
      this.isLilyReady = true;
    },

    /**
     * Methods called after a event from widgetEvents was fired
     */
    onWidgetClick: function() {
      this.trigger('lily.expand');
    },

    onMessageToOperator: function(message) {
      // Comming from third party. Check param integrity
      if (!_.isString(message)) return;
      this.trigger('lily.onMessageToOperator', message);
    },

    /**
     * Utility methods accessible on the saio object
     */
    registerApp: function(frame, uid) {
      appsRegistry[uid] = frame;
    },

    getRegisteredApp: function(uid) {
      return appsRegistry[uid] || undefined;
    },

    getHost: function(href) {
      this.emptyLink.href = href;
      return this.emptyLink.hostname;
    },

    getOrigin: function(url) {
      // Use the anchor tag to guarantee a fully formed URL.
      this.emptyLink.href = url;
      var parts = this.emptyLink.href.split('/');
      return parts[0] + '//' + parts[2];
    },

    onTargetMessage: function(event) {
      var message;

      try {
        message = JSON.parse(event.data);
      } catch (err) {
        return;
      }

      var sender = message.sender,
          hostLocation;

      // Check that the message comes from a known origin
      // (an app we previously defined and registered in appRegistry)
      if (sender && appsRegistry[sender]) {
        hostLocation = appsRegistry[sender];
      }

      if (hostLocation && this.getHost(event.origin) === hostLocation.host) {
        // Scope should be saio (only scope for message comming from a saio iframe)
        if (event.origin === hostLocation.origin && message.scope === 'saio') {
          // Do something with received message
          console.log(message.scope + ': ' + message.name);
          saio.trigger(message.name, message.data);
        }
      }

    },

    loadStylesheet: function(url) {
      var link = document.createElement('link');
      link.rel  = 'stylesheet';
      link.type = 'text/css';
      link.href = url;

      // There is at least 1 script tag on the page
      // (the one that loaded the saio widget script)
      // Insert before that tag.
      var entry = document.getElementsByTagName('script')[0];
      entry.parentNode.insertBefore(link, entry);
    },

  }, Events);

};
;/* jshint strict: false */
var sdk = (function() {

  if (sdk) return sdk;

  var configMap = {
    'setOperatorGroup': 'setOperatorGroup'
  };

  // Can be triggered on the host website using the sdk
  var apiMap = {
    // Widget & iframe show/hide events
    'api.widget.show':        'showWidget',
    'api.widget.hide':        'hideWidget',
    'api.widget.onShow':      'onWidgetShow',
    'api.widget.onHide':      'onWidgetHide',
    'api.box.expand':         'expandBox',
    'api.box.shrink':         'shrinkBox',
    'api.box.onExpand':       'onLilyExpand',
    'api.box.onShrink':       'onLilyShrink',

    //
    'api.onReady':              'onReady',
    'api.onChatSessionStart':   'onChatSessionStart',
    'api.onAviSessionStart':    'onAviSessionStart',
    'api.onMessageToOperator':  'onMessageToOperator',
    'api.onQuestionAskedToAvi': 'onQuestionAskedToAvi'
  };

  var configMethods = {
    setOperatorGroup: function(groupId) {
      if (!_.isString(groupId)) {
        console.error('groupId should be a string containing the operator group id');
      }
      saio.trigger('config.setOperatorGroup', groupId);
    },
  };

  var apiMethods = {
    showWidget: function() {
      saio.trigger('widget.show');
    },

    hideWidget: function() {
      saio.trigger('widget.hide');
    },

    onWidgetShow: function(callback) {
      saio.on('widget.onShow', function() {
        if (_.isFunction(callback)) {
          callback();
        }
      });
    },

    onWidgetHide: function(callback) {
      saio.on('widget.onHide', function() {
        if (_.isFunction(callback)) {
          callback();
        }
      });
    },

    expandBox: function() {
      saio.trigger('lily.expand');
    },

    shrinkBox: function() {
      saio.trigger('lily.shrink');
    },

    onLilyExpand: function(callback) {
      saio.on('lily.onExpand', function() {
        if (_.isFunction(callback)) {
          callback();
        }
      });
    },

    onLilyShrink: function(callback) {
      saio.on('lily.onShrink', function() {
        if (_.isFunction(callback)) {
          callback();
        }
      });
    },

    onMessageToOperator: function(callback) {
      saio.on('lily.onMessageToOperator', function(message) {
        if (_.isFunction(callback)) {
          callback(message);
        }
      });
    },
  };

  function config(name, obj) {
    if (!_.isString(name)) {
      throw new Error('first argument should be a string');
    }

    if (configMap[name] && configMethods[configMap[name]]) {
      configMethods[configMap[name]].call(this, obj);
    }
  }

  function api(name, obj) {
    if (!_.isString(name)) {
      throw new Error('first argument should be a string');
    }

    if (apiMap[name] && apiMethods[apiMap[name]]) {
      apiMethods[apiMap[name]].call(this, obj);
    }
  }

  return {
    config: config,
    api: api
  };

})();
;/* jshint strict: false */
/* global _, saio, xdm, Events */

var Iframe = (function() {

  return _.extend(xdm, Events, {

    createIframe: function(options) {
      var $iframe = document.createElement('iframe');

      this.setAttributes($iframe, options);
      this.setInlineStyle($iframe, options.styles);
      return $iframe;
    },

    createWidget: function(options) {
      var $widget = document.createElement('div');

      $widget.setAttribute('id', options.frameId);
      $widget.innerHTML = options.html;
      this.setInlineStyle($widget, options.styles);
      return $widget;
    },

    createContainer: function(options) {
      var $container = document.createElement('div');

      $container.setAttribute('id', options.containerId);
      this.setInlineStyle($container, options.styles);
      return $container;
    },

    insertIframe: function(iframe, options) {
      return document.getElementById(options.containerId).appendChild(iframe);
    },

    insertInBody: function(element) {
      saio.hostBody.appendChild(element);
    },

    hide: function() {
      this.setInlineStyle(this.el, 'display', 'none');
      window.focus();
    },

    show: function() {
      this.removeInlineStyle('display');
    },

    setAttributes: function(element, attributes) {
      _.each(attributes, function(value, attribute) {
        element.setAttribute(attribute, value);
      });
    },

    setInlineStyle: function(el, property, value) {
      var stylesObj = {},
          style = el.style;

      // Single property
      if (_.isString(property)) {
        stylesObj[property] = value;
      } else { // Object with one or more properties
        stylesObj = property;
      }

      // IE > 9
      if ('setProperty' in style) {
        _.each(stylesObj, function(value, property) {
          style.setProperty(property, '' + value, 'important');
        }) ;
      } else {
        _setInlineStyleCompat(el, stylesObj);
      }
    },

    removeInlineStyle: function(property) {
      var style = this.el.style;
      if ('removeProperty' in style) {
        style.removeProperty(property);
      } else {
        _removeInlineStyleCompat(property);
      }
    },

  });

  function _setInlineStyleCompat(el, stylesObj) {
    var props = [];
    _.each(stylesObj, function(value, property) {
      props.push(property + ':' + value + ' !important');
    });

    el.style.cssText = props.join(';');
  }

  function _removeInlineStyleCompat() {
    this._setInlineStyleCompat({});
  }

}());
;/* jshint strict: false */
/* global _, saio, Iframe */

var LilyIframe = function() {

  return _.extend({

    // Create a unique identifier for the lily App
    // that will be used to identify the iframed saio app
    // to ensure a secured communication between host && client
    // using the postMessage api.
    uid: 'lily',

    target: '{{ url("lily_app_index", { licence: licence }) }}',
    origin: saio.getOrigin('{{ url("lily_app_index", { licence: licence }) }}'),
    host: saio.getHost(this.origin),
    window: undefined,

    // Will be set when creating the dom element
    el: undefined,

    // Html id for the element
    frameId: 'lilyApp',

    // Internal flags and config variables
    shouldOpenStandalone: false,

    // A map of events for this object
    // Callbacks will be bound to the "view", with `this` set properly.
    // Uses event delegation for efficiency.
    events: {
      'lily.load': 'onLoad',
      'lily.ready': 'onReady',
      'lily.expand': 'showApp',
      'lily.shrink': 'hideApp',
    },

    load: function() {

      this.el = this.createLily(this.getElOptions());

      // Keep a reference to the iframe window object.
      // Will be used later to send messages using postMessage.
      // Child iframe window object can also be found in the "frame" array
      this.window = saio.hostDocument.getElementById(this.frameId).contentWindow;

      // Create listeners for the events listed in the 'events' objects
      this.delegateEvents(saio, this.events);

      // Register this unique id for the lily App iframe
      saio.registerApp(this, this.uid);
    },

    getElOptions: function() {
      return {
        iframe: {
          'id': this.frameId,
          'allowTransparency': 'true',
          'frameBorder': '0',
          'scrolling': 'yes',
          'name': 'saio_lily_app',
          'role': 'dialog',
          'src': this.target
        },

        container: {
          containerId: 'lilyAppContainer',
          styles: {
            'display': 'none',
          }
        },
      };
    },

    createLily: function(options) {
      if (!options) return;

      // Create dom elements
      var $lilyContainer = options.container ? this.createContainer(options.container) : null,
          $lilyIframe    = options.iframe ? this.createIframe(options.iframe) : null;

      // Insert dom elements in the host site dom
      this.insertInBody($lilyContainer);
      this.insertIframe($lilyIframe, options.container);

      return $lilyContainer;
    },

    onLoad: function(options) {
      if (options.shouldOpenStandalone) {
        this.shouldOpenStandalone = true;
      }

      // Send informations about the host to lily iframe
      // for tracking purposes
      this.sendMessage('host.sendInfo', {
        host: window.location.host || null,
        path: window.location.pathname || null,
        href: window.location.href || null,
        protocol: window.location.protocol || null,
        referrer: document.referrer || null,
        snippetVersion: snippetVersion
      });
    },

    onReady: function(options) {
      // Notify the mediator that the lily app is ready
      saio.trigger('lily.onReady');

      if (options && options.displayApp) {
        this.showApp();
      } else {
        saio.trigger('widget.show');
      }
    },

    hideApp: function() {
      // Go no further if app is in standalone mode.
      if (saio.shouldOpenStandalone) return;

      // Hide \o/
      this.hide();

      // Global flag for the state of the app
      //
      // NOTE: It would probably make more sence and be less messy
      // to have a `state` associated with each app and getter/setters
      // to access/modify this state
      saio.lilyIsShown = false;

      // Widget should be shown after the app was hidden
      saio.trigger('widget.show');

      // Will be used for the api to add behaviour onShrink
      saio.trigger('lily.onShrink');
    },

    showApp: function() {
      var firstOpen = this.firstOpen;

      // If the app should be opened in standalone mode (new tab,
      // currently only for mobile devices), do so and return here.
      // Widget should remain visible.
      if (this.shouldOpenStandalone) {
        return this.standaloneOpen();
      }

      saio.lilyIsShown = true;

      // Widget should hide before the app is shown
      saio.trigger('widget.hide');

      // Show \o/
      this.show();

      // Notify the lily app that it's been shown
      this.sendMessage('lily.shown', {
        firstOpen: firstOpen
      });

      this.firstOpen = false;

      // Will be used for the api to add behaviour onExpand
      saio.trigger('lily.onExpand');
    },

    standaloneOpen: function() {
      var win = window.open(this.target, '_blank');
      win.focus();
    },

  }, Iframe);

};
;/* jshint strict: false */
/* global _, saio, Iframe */

var WidgetIframe = function() {

 return _.extend({

    // Create a unique identifier for the lily App
    // that will be used to identify the iframed saio app
    // to ensure a secured communication between host && client
    // using the postMessage api.
    uid: 'widget',

    // Widget is not an iframe (for now. Could be in the future,
    // hence the structure mimicking the structure for creating lily)

    // Will be set when creating the dom element
    el: undefined,

    // Html id for the element
    frameId: 'lily-widget-container',

    // Flag used for analytics tracking
    firstShow: true,

    // A map of events for this object
    // Callbacks will be bound to the "view", with `this` set properly.
    // Uses event delegation for efficiency.
    events: {
      'widget.show': 'showWidget',
      'widget.hide': 'hideWidget',
    },

    load: function() {
      this.el = this.createWidget(this.getElOptions());
      this.insertInBody(this.el);

      // Create listeners for the events listed in the 'events' objects
      this.delegateEvents(saio, this.events);

      // Register this unique id for the lily App iframe
      saio.registerApp(this, this.uid);

      _.addEvent(this.el, 'click', _.bind(this.onWidgetClick, this));
    },

    getElOptions: function() {
      return {
        iframe: {
          // not an iframe for now
        },
        frameId: this.frameId,
        html: '{{ widget }}',
        styles: {
          'display': 'none',
        }
      };
    },

    // Not great, but satisfactory enough for now
    sendMessageToLily: function(name, obj) {
      var lily = saio.getRegisteredApp('lily');
      if (lily) {
        lily.sendMessage(name, obj);
      }
    },

    onWidgetClick: function() {
      this.sendMessage('widget.click');
      saio.trigger('widget.click');
    },

    showWidget: function() {
      if (saio.widgetIsShown || saio.lilyIsShown) {
        return;
      }

      if (saio.isLilyReady) {
        this.show();
      } else {
        return saio.once('lily.onReady', this.showWidget, this);
      }

      this.sendMessageToLily('widget.show', {
        firstShow: this.firstShow
      });

      this.firstShow = false;
      saio.widgetIsShown = true;

      saio.trigger('widget.onShow');
    },

    hideWidget: function() {
      this.hide();
      saio.widgetIsShown = false;

      saio.trigger('widget.onHide');
    }

  }, Iframe, Events);

};
;/* jshint strict: false */
/* global _, sdk, window, Events, core, LilyIframe, WidgetIframe */

/**
 * The whole project will get wrapped in:
 *
 * (function(window, undefined) {
 *   (...)
 * })(this);
 *
 * In the build file created by the grunt task
 */

// shorthand reference to native types prototype methods:
var slice = [].slice;
var toString = {}.toString;

// Reference to the saio array queue created
// in snippet on publisher's website
var saioq = window.saio || [];

// Internal saio object
var saio = new core();
_.extend(saio, sdk);

// IE version < 10 or unsupported features such as JSON or postMessage.
// Stop here, not supported
if (_.isUnsuported()) return;

// Snippet version.
var snippetVersion = saioq && saioq.SNIPPET_VERSION ?
  parseFloat(saioq.SNIPPET_VERSION, 10) : 0;

// Initialize.
saio.initialize();
var lily = new LilyIframe().load();
var widget = new WidgetIframe().load();

// Before swapping the global, replay an existing global `saio` queue.
while (saioq && saioq.length > 0) {
  var args = saioq.shift();
  var method = args.shift();

  if (saio[method]) {
    saio[method].apply(saio, args);
  }
}

// Finally, replace the global queue with the real `saio` singleton.
window.saio = sdk;
})(this);